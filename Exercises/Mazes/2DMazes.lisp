;------------------------------------------
;| Jesús Alexis Torreblanca Faces         |
;| Inteligencia Artificial                |
;| Resuelve laberintos 2D                 |
;------------------------------------------
;| Probar en: http://idic.likufanele.com/~fundamentosia/Maze2D/

;Librería que genera los laberintos
(load "maze_lib.lisp")

;Metodos de Busqueda para la solución del algoritmo
(add-algorithm 'depth-first)
(add-algorithm 'breath-first)
(add-algorithm 'best-first)
(add-algorithm 'A*)

(defparameter *open* '()) ;Frontera de Busqueda
(defparameter *memory* '()) ;Memoria de Intentos Previos

(defparameter *id* 0)
(defparameter *current-ancestor*  nil)
(defparameter *solution* nil)
(defparameter *filas* 0)
(defparameter *columnas* 0)
(defparameter *sol* nil)
(defparameter *ops* '((:Arriba 0)
                      (:Arriba-derecha 1)
                      (:Derecha 2)
                      (:Abajo-derecha 3)
                      (:Abajo 4)
                      (:Abajo-izquierda 5)
                      (:Izquierda 6)
                      (:Arriba-izquierda 7)))

(defun create-node (estado operador funcion)
  "Función la cual crea un nodo con la estructura (<id> <estado> <id-ancestro> <operador> <función-heuristica>)"
  (incf *id*)
  (list (1- *id*) estado *current-ancestor* (second operador) funcion))

(defun insert-to-open (estado operador metodo)
  "Función la cual dependiendo del metodo que se le pase inserta a la frontera de busqueda el nodo"
  (let ((nodo '()))
    (cond ((equal metodo :depth-first)
           (setq nodo (create-node estado operador nil))
           (push nodo *open*))
          ((equal metodo :breath-first)
           (setq nodo (create-node estado operador nil))
           (setq *open* (append *open* (list nodo))))
          ((equal metodo :best-first)
           (setq nodo (create-node estado operador (get-distance estado)))
           (push nodo *open*)
           (order-open))
          ((equal metodo :A*)
           (setq nodo (create-node estado operador nil))
           (setf (fifth nodo) (A-star nodo))
           (if (remember-state-open? (second nodo) *open*)
               (compare-node nodo *open*)
               (push nodo *open*))
           (order-open))
          (T Nil))))

(defun get-from-open ()
  "Función que obtiene el primer nodo de la frontera de busqueda"
  (pop *open*))

(defun order-open ()
  "Funcion que permite reordenar la frontera de busqueda"
  (setq *open* (stable-sort *open* #'< :key #'(lambda (x) (fifth x)))))

(defun get-distance (estado)
  "Función basada en la ecuación para obtener la distancia entre dos puntos (((x2-x1)^2 +(y2-y1)^2)^1/2) pero ligeramente modificada (x2-x1) + (y2-y1)"
  (+  (- (max (aref estado 0) (aref *goal* 0))
         (min (aref estado 0) (aref *goal* 0)))
      (- (max (aref estado 1) (aref *goal* 1))
         (min (aref estado 1) (aref *goal* 1)))))

(defun compare-node (nodo open)
  "Funcion la cual busca si el nodo a insertar está ya en la frontera y si es asi compara el valor de su función heuristica"
  (let ((nodo-copia-de-open nil))
    (cond ((null open) (push nodo *open*))
          ((and (equal (aref (second nodo) 0) (aref (second (first open)) 0))
                (equal (aref (second nodo) 1) (aref (second (first open)) 1))) (setq nodo-copia-de-open (first open))
           (if (< (fifth nodo) (fifth nodo-copia-de-open))
               (progn
                 (delete nodo-copia-de-open open)
                 (push nodo *open*))))
          (T (compare-node nodo (rest open))))))

(defun get-cost (nodo cont)
  "Función la cual obtiene el nivel de profundidad (costo) de un nodo determinado"
  (labels ((locate-node (id lista)
             (cond ((null lista) Nil)
                   ((equal id (first (first lista))) (first lista))
                   (T (locate-node id (rest lista))))))
    (let ((current (locate-node (third nodo) *memory*)))
      (loop while (not (null current)) do
           (setq cont (incf cont))
           (setq current (locate-node (third current) *memory*))))
    cont))

(defun A-star (nodo)
  "Función que obtiene el valor de la función de evaluación del algoritmo A* f(x) = g(x) + h(x)"
  (+ (get-distance (second nodo)) (get-cost nodo 0)))

(defun valid-operator? (op estado)
  "Predicado que valida si un operador es aplicable a un estado determinado"
(let* ((fila (aref estado 0))
         (columna (aref estado 1))
         (casillaActual (get-cell-walls fila columna))
         (operador (second op))
         (casillaArriba 0)
         (casillaAbajo 0)
         (casillaIzquierda 0)
         (casillaDerecha 0))

    (if (not (= fila 0)) (setq casillaArriba (get-cell-walls (1- fila) columna)))
    (if (not (= columna 0)) (setq casillaIzquierda (get-cell-walls fila (1- columna))))
	  (if (not (= columna (1- *columnas*))) (setq casillaDerecha (get-cell-walls fila (1+ columna))))
    (if (not (= fila (1- *filas*))) (setq casillaAbajo (get-cell-walls (1+ fila) columna)))

    (cond ((= operador 0)
           (and (not (= fila 0))
                (= (boole boole-and casillaActual 1) 0)))
          ((= operador 1)
           (and (not (= fila 0))
                (not (= columna (1- *columnas*)))
                (and (or (= (boole boole-and casillaActual 1) 0)
                         (= (boole boole-and casillaDerecha 1) 0))
                     (or (= (boole boole-and casillaArriba 2) 0)
                         (= (boole boole-and casillaDerecha 1) 0))
                     (or (= (boole boole-and casillaArriba 2) 0)
                         (= (boole boole-and casillaActual 2) 0))
                     (or (= (boole boole-and casillaActual 1) 0)
                         (= (boole boole-and casillaActual 2) 0)))))
          ((= operador 2) (and (not (= columna (1- *columnas*)))
                         (= (boole boole-and casillaActual 2) 0)))
          ((= operador 3) (and (not (= fila (1- *filas*)))
                         (not (= columna (1- *columnas*)))
                         (and (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaDerecha 4) 0))
                              (or (= (boole boole-and casillaAbajo 2) 0)
                                  (= (boole boole-and casillaDerecha 4) 0))
                              (or (= (boole boole-and casillaAbajo 2) 0)
                                  (= (boole boole-and casillaActual 2) 0))
                              (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaActual 2) 0)))))
          ((= operador 4) (and (not (= fila (1- *filas*)))
                         (= (boole boole-and casillaActual 4) 0)))
          ((= operador 5) (and (not (= fila (1- *filas*)))
                         (not (= columna 0))
                         (and (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaIzquierda 4) 0))
                              (or (= (boole boole-and casillaAbajo 8) 0)
                                  (= (boole boole-and casillaIzquierda 4) 0))
                              (or (= (boole boole-and casillaAbajo 8) 0)
                                  (= (boole boole-and casillaActual 8) 0))
                              (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaActual 8) 0)))))
          ((= operador 6) (and (not (= columna 0))
                         (= (boole boole-and casillaActual 8) 0)))
          ((= operador 7) (and (not (= fila 0))
                         (not (= columna 0))
                         (and (or (= (boole boole-and casillaActual 1) 0)
                                  (= (boole boole-and casillaIzquierda 1) 0))
                              (or (= (boole boole-and casillaArriba 8) 0)
                                  (= (boole boole-and casillaIzquierda 1) 0))
                              (or (= (boole boole-and casillaArriba 8) 0)
                                  (= (boole boole-and casillaActual 8) 0))
                              (or (= (boole boole-and casillaActual 1) 0)
                                  (= (boole boole-and casillaActual 8) 0)))))
          (T nil))))

(defun apply-operator (operador estado)
  "Función que aplica un operador a un estado"
    (let* ((fila (aref estado 0))
        (columna (aref estado 1))
        (op (first operador))
        (estado nil))
    (case op
      (:Arriba (setq estado (make-array 2 :initial-contents (list (1- fila) columna))))
      (:Arriba-derecha (setq estado (make-array 2 :initial-contents (list (1- fila) (1+ columna)))))
      (:Derecha (setq estado (make-array 2 :initial-contents (list fila (1+ columna)))))
      (:Abajo-derecha (setq estado (make-array 2 :initial-contents (list (1+ fila) (1+ columna)))))
      (:Abajo (setq estado (make-array 2 :initial-contents (list (1+ fila) columna))))
      (:Abajo-izquierda (setq estado (make-array 2 :initial-contents (list (1+ fila) (1- columna)))))
      (:Izquierda (setq estado (make-array 2 :initial-contents (list fila (1- columna)))))
      (:Arriba-izquierda (setq estado (make-array 2 :initial-contents (list (1- fila) (1- columna)))))
      (T "Error"))
    estado))

(defun expand (estado)
  "Función que expande el estado a todos sus posibles descendientes"
  (let ((descendientes nil)
        (nuevo-estado nil))
    (dolist (op *ops* descendientes)
      (if (valid-operator? op estado)
        (progn
          (setq nuevo-estado (apply-operator op estado))
          (if (not (null nuevo-estado))
                (setq descendientes (cons (list nuevo-estado op) descendientes))))))))

(defun filter-memories (lista-estados-y-ops)
  "Funcion que filtra los estados que se encuentran en la memoria"
  (cond ((null  lista-estados-y-ops)  Nil)
        ((remember-state-memory? (first (first  lista-estados-y-ops)) *memory*)
          (filter-memories  (rest  lista-estados-y-ops)))
        (T  (cons (first lista-estados-y-ops) (filter-memories  (rest  lista-estados-y-ops))))))

(defun remember-state-memory? (estado memoria)
  "Predicado que nos dice si un estado se encuentra en la memoria"
  (cond ((null  memoria)  Nil)
        ((and (equal (aref estado 0) (aref (second (first memoria)) 0))
              (equal (aref estado 1) (aref (second (first memoria)) 1))) T)
        (T (remember-state-memory? estado (rest memoria)))))

(defun filter-open (lista-estados-y-ops)
  "Funcion que filtra los estados que se encuentran en la frontera de busqueda"
  (cond ((null  lista-estados-y-ops)  Nil)
        ((remember-state-open? (first (first  lista-estados-y-ops)) *open*)
         (filter-open  (rest  lista-estados-y-ops)))
        (T  (cons (first lista-estados-y-ops) (filter-open  (rest  lista-estados-y-ops))))))

(defun remember-state-open? (estado open)
  "Predicado que nos dice si un estado se encuentra en la frontera de busqueda"
  (cond ((null  open)  Nil)
        ((and (equal (aref estado 0) (aref (second (first open)) 0))
              (equal (aref estado 1) (aref (second (first open)) 1))) T)
        (T (remember-state-memory? estado (rest open)))))

(defun extract-solution (nodo)
  "Función que extrae la solución del laberinto"
  (labels ((locate-node (id lista)
             (cond ((null lista) Nil)
                   ((equal id (first (first lista))) (first lista))
                   (T (locate-node id (rest lista))))))
    (let ((current (locate-node (first nodo) *memory*)))
      (loop while (not (null current)) do
           (if (not (null (fourth current)))
           (push (fourth current) *sol*))
           (setq current (locate-node (third current) *memory*))))
    *sol*))

(defun reset-all ()
  "Función que limpia todas las variables globales"
  (setq  *open*  nil)
  (setq  *memory*  nil)
  (setq  *id*  0)
  (setq  *sol*  nil)
  (setq  *current-ancestor*  nil)
  (setq *solution* nil))

(defun depth-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :depth-first))
    (setq *filas* (get-maze-rows))
    (setq *columnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (expand estado)))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(defun breath-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :breath-first))
    (setq *filas* (get-maze-rows))
    (setq *columnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (expand estado)))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(defun best-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :best-first))
    (setq *filas* (get-maze-rows))
    (setq *columnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (filter-open (expand estado))))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(defun A* ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :A*))
    (setq *filas* (get-maze-rows))
    (setq *columnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (expand estado)))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(start-maze)
