(load "maze_lib.lisp")

(add-algorithm 'depth-first)
(add-algorithm 'breath-first)
(add-algorithm 'best-first)
(add-algorithm 'A*)

(defparameter *open* '())
(defparameter *memory* '())

(defparameter *id* 0)
(defparameter *current-ancestor*  nil)
(defparameter *solution* nil)
(defparameter *numeroDeFilas* 0)
(defparameter *numeroDeColumnas* 0)
(defparameter *sol* nil)
(defparameter *ops* '((:Arriba 0)
                      (:Arriba-derecha 1)
                      (:Derecha 2)
                      (:Abajo-derecha 3)
                      (:Abajo 4)
                      (:Abajo-izquierda 5)
                      (:Izquierda 6)
                      (:Arriba-izquierda 7)))

(defun create-node (estado operador funcion)
  (incf *id*)
  (list (1- *id*) estado *current-ancestor* (second operador) funcion))

(defun insert-to-open (estado operador metodo)
  (let ((nodo '()))
    (cond ((equal metodo :depth-first)
           (setq nodo (create-node estado operador nil))
           (push nodo *open*))
          ((equal metodo :breath-first)
           (setq nodo (create-node estado operador nil))
           (setq *open* (append *open* (list nodo))))
          ((equal metodo :best-first)
           (setq nodo (create-node estado operador (get-distance estado)))
           (push nodo *open*)
           (order-open))
          ((equal metodo :A*)
           (setq nodo (create-node estado operador (A-star *goal*)))
           (push nodo *open*)
           (order-open))
          (T Nil))))

(defun get-from-open ()
  (pop *open*))

(defun order-open ()
  "Funcion que permite reordenar la frontera de busqueda"
  (setq *open* (stable-sort *open* #'< :key #'(lambda (x) (fifth x)))))

(defun get-distance (estado)
  "Función basada en la ecuación para obtener la distancia entre dos puntos (((x2-x1)^2 +(y2-y1)^2)^1/2)"
  (sqrt (+  (expt (- (max (aref estado 0) (aref *goal* 0))
                     (min (aref estado 0) (aref *goal* 0))) 2)
            (expt (- (max (aref estado 1) (aref *goal* 1))
                     (min (aref estado 1) (aref *goal* 1))) 2))))

(defun valid-operator? (op estado)
(let* ((fila (aref estado 0))
         (columna (aref estado 1))
         (casillaActual (get-cell-walls fila columna))
         (operador (second op))
         (casillaArriba 0)
         (casillaAbajo 0)
         (casillaIzquierda 0)
         (casillaDerecha 0))

    (if (not (= fila 0)) (setq casillaArriba (get-cell-walls (1- fila) columna)))
    (if (not (= columna 0)) (setq casillaIzquierda (get-cell-walls fila (1- columna))))
	(if (not (= columna (1- *numeroDeColumnas*))) (setq casillaDerecha (get-cell-walls fila (1+ columna))))
    (if (not (= fila (1- *numeroDeFilas*))) (setq casillaAbajo (get-cell-walls (1+ fila) columna)))


    (cond ((= operador 0)
           (and (not (= fila 0))
                (= (boole boole-and casillaActual 1) 0)))
          ((= operador 1)
           (and (not (= fila 0))
                (not (= columna (1- *numeroDeColumnas*)))
                (and (or (= (boole boole-and casillaActual 1) 0)
                         (= (boole boole-and casillaDerecha 1) 0))
                     (or (= (boole boole-and casillaArriba 2) 0)
                         (= (boole boole-and casillaDerecha 1) 0))
                     (or (= (boole boole-and casillaArriba 2) 0)
                         (= (boole boole-and casillaActual 2) 0))
                     (or (= (boole boole-and casillaActual 1) 0)
                         (= (boole boole-and casillaActual 2) 0)))))
          ((= operador 2) (and (not (= columna (1- *numeroDeColumnas*)))
                         (= (boole boole-and casillaActual 2) 0)))
          ((= operador 3) (and (not (= fila (1- *numeroDeFilas*)))
                         (not (= columna (1- *numeroDeColumnas*)))
                         (and (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaDerecha 4) 0))
                              (or (= (boole boole-and casillaAbajo 2) 0)
                                  (= (boole boole-and casillaDerecha 4) 0))
                              (or (= (boole boole-and casillaAbajo 2) 0)
                                  (= (boole boole-and casillaActual 2) 0))
                              (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaActual 2) 0)))))
          ((= operador 4) (and (not (= fila (1- *numeroDeFilas*)))
                         (= (boole boole-and casillaActual 4) 0)))
          ((= operador 5) (and (not (= fila (1- *numeroDeFilas*)))
                         (not (= columna 0))
                         (and (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaIzquierda 4) 0))
                              (or (= (boole boole-and casillaAbajo 8) 0)
                                  (= (boole boole-and casillaIzquierda 4) 0))
                              (or (= (boole boole-and casillaAbajo 8) 0)
                                  (= (boole boole-and casillaActual 8) 0))
                              (or (= (boole boole-and casillaActual 4) 0)
                                  (= (boole boole-and casillaActual 8) 0)))))
          ((= operador 6) (and (not (= columna 0))
                         (= (boole boole-and casillaActual 8) 0)))
          ((= operador 7) (and (not (= fila 0))
                         (not (= columna 0))
                         (and (or (= (boole boole-and casillaActual 1) 0)
                                  (= (boole boole-and casillaIzquierda 1) 0))
                              (or (= (boole boole-and casillaArriba 8) 0)
                                  (= (boole boole-and casillaIzquierda 1) 0))
                              (or (= (boole boole-and casillaArriba 8) 0)
                                  (= (boole boole-and casillaActual 8) 0))
                              (or (= (boole boole-and casillaActual 1) 0)
                                  (= (boole boole-and casillaActual 8) 0)))))
          (T nil))))

(defun apply-operator (operador estado)
    (let* ((fila (aref estado 0))
        (columna (aref estado 1))
        (op (first operador))
        (estado nil))
    (case op
      (:Arriba (setq estado (make-array 2 :initial-contents (list (1- fila) columna))))
      (:Arriba-derecha (setq estado (make-array 2 :initial-contents (list (1- fila) (1+ columna)))))
      (:Derecha (setq estado (make-array 2 :initial-contents (list fila (1+ columna)))))
      (:Abajo-derecha (setq estado (make-array 2 :initial-contents (list (1+ fila) (1+ columna)))))
      (:Abajo (setq estado (make-array 2 :initial-contents (list (1+ fila) columna))))
      (:Abajo-izquierda (setq estado (make-array 2 :initial-contents (list (1+ fila) (1- columna)))))
      (:Izquierda (setq estado (make-array 2 :initial-contents (list fila (1- columna)))))
      (:Arriba-izquierda (setq estado (make-array 2 :initial-contents (list (1- fila) (1- columna)))))
      (T "Error"))
    estado))

(defun expand (estado)
  (let ((descendientes nil)
        (nuevo-estado nil))
    (dolist (op *ops* descendientes)
      (if (valid-operator? op estado)
        (progn
          (setq nuevo-estado (apply-operator op estado))
          (if (not (null nuevo-estado))
                (setq descendientes (cons (list nuevo-estado op) descendientes))))))))

(defun filter-memories (lista-estados-y-ops)
  (cond ((null  lista-estados-y-ops)  Nil)
        ((remember-state-memory? (first (first  lista-estados-y-ops)) *memory*)
          (filter-memories  (rest  lista-estados-y-ops)))
        (T  (cons (first lista-estados-y-ops) (filter-memories  (rest  lista-estados-y-ops))))))

(defun remember-state-memory? (estado memoria)
  (cond ((null  memoria)  Nil)
        ((and (equal (aref estado 0) (aref (second (first memoria)) 0))
              (equal (aref estado 1) (aref (second (first memoria)) 1))) T)
        (T (remember-state-memory? estado (rest memoria)))))

(defun filter-open (lista-estados-y-ops)
  (cond ((null  lista-estados-y-ops)  Nil)
        ((remember-state-open? (first (first  lista-estados-y-ops)) *open*)
         (filter-open  (rest  lista-estados-y-ops)))
        (T  (cons (first lista-estados-y-ops) (filter-open  (rest  lista-estados-y-ops))))))

(defun remember-state-open? (estado open)
  (cond ((null  open)  Nil)
        ((and (equal (aref estado 0) (aref (second (first open)) 0))
              (equal (aref estado 1) (aref (second (first open)) 1))) T)
        (T (remember-state-memory? estado (rest open)))))

(defun extract-solution (nodo)
  (labels ((locate-node (id lista)
             (cond ((null lista) Nil)
                   ((equal id (first (first lista))) (first lista))
                   (T (locate-node id (rest lista))))))
    (let ((current (locate-node (first nodo) *memory*)))
      (loop while (not (null current)) do
           (if (not (null (fourth current)))
           (push (fourth current) *sol*))
           (setq current (locate-node (third current) *memory*))))
    *sol*))

(defun reset-all ()
  (setq  *open*  nil)
  (setq  *memory*  nil)
  (setq  *id*  0)
  (setq  *sol*  nil)
  (setq  *current-ancestor*  nil)
  (setq *solution* nil))

(defun depth-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :depth-first))
    (setq *numeroDeFilas* (get-maze-rows))
    (setq *numeroDeColumnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (expand estado)))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(defun breath-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :breath-first))
    (setq *numeroDeFilas* (get-maze-rows))
    (setq *numeroDeColumnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (expand estado)))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(defun best-first ()
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (meta-encontrada nil)
        (metodo :best-first))
    (setq *numeroDeFilas* (get-maze-rows))
    (setq *numeroDeColumnas* (get-maze-cols))
    (insert-to-open *start* nil metodo)
    (loop until (or meta-encontrada (null *open*)) do
         (setq nodo (get-from-open)
               estado (second nodo))
         (push nodo *memory*)
         (cond ((and (equal (aref *goal* 0)
                            (aref estado 0))
                     (equal (aref *goal* 1)
                            (aref estado 1)))
                (setq *solution* (extract-solution nodo))
                (setq meta-encontrada T))
               (T (setq *current-ancestor* (first nodo)
                        sucesores (filter-memories (filter-open (expand estado))))
                  (loop for elem in sucesores do
                       (insert-to-open (first elem) (second elem) metodo)))))))

(start-maze)

